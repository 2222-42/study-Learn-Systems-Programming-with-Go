# chapter 02 低レベルアクセスへの入口1： io.Writer

本章から3章分にわたって、Go言語がOS直上の低レイヤーを扱いやすくするために提供している抽象化レイヤーを紹介

この抽象化により低レイヤーを扱いやすい構造になっているから、簡単に、少ない記述で、比較的高速に、多くのことが達成できる

- io.Writer ：出力の抽象化
- io.Reader ：入力の抽象化
- channel ：通知の抽象化

## 2.1 io.WriterはOSが持つファイルのシステムコールの相似形

前章の例での最後にシステムコールsyscall.Write() が呼び出されているようすを見ました。
OSでは、このシステムコールを、ファイルディスクリプタといわれるものに対して呼びます。

ファイルディスクリプタ：
- 一種の識別子（数値）(e.g. `f.fd` )
- この数値を指定してシステムコールを呼び出すと、数値に対応するモノにアクセスできる
- ファイルに限らず、標準入出力、ソケット、OSやCPUに内蔵されている乱数生成の仕組みなど、本来ファイルではないものにも割り当てられる

ファイルディスクリプタは、OSがカーネルのレイヤーで用意している抽象化の仕組み

ただし同じPOSIX 系OSでも、Windowsだとソケットはファイルとして扱えなかったり、ファイル出力とコンソール出力でAPI が違っていたりして、
システムによる違いも少なからずある

Go言語では、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備し、OSによるAPI の差異を吸収しています。
その一例が、本章で取り上げるio.Writerです

`io.Writer`はGo言語のインタフェースという仕組みとして実装されているので、次節ではまずGo言語のインタフェースと、それに関連するGo言語の構造体について説明

Go言語でも、直接ファイルディスクリプタを指定してファイルのインスタンスを作り出す関数はあります。(cf: chap 6)
```
file, err := os.NewFile( ファイルディスクリプタ, 名前)
```

## 2.2 Go言語のインタフェース

Go言語のインタフェースは、構造体などの具象型が満たすべき仕様、つまりは持つべきメソッドを表現するための言語機能

Go言語にはクラスがなく、構造体しかありませんが、構造体がメソッドを持てます

func キーワードとメソッドのシグネチャの定義との間にレシーバーを置くと(ここでは`(g Greeter)`)、構造体にメソッドを定義したことになります
(副作用のあるメソッドではレシーバーの型をポインタ型（(g *Greeter)）にします。)

インタフェースで宣言されているすべてのメソッドが、データ型に対して定義されている場合、「そのデータ型はインタフェースを満たす」と表現

Go言語のコンパイラが、構造体のインスタンスのポインタをインタフェース型の変数に代入するコードを見つけると、そこで構造体とインタフェースの互換性をチェックします

Go言語では構造体がポインタであってもフィールド（構造体に含まれる各データ型）へのアクセスの方法は変わりませんし（いずれも「.」演算子が使えます）、
ガベージコレクタが適切に掃除してくれるため、宣言時以外はポインタであることを意識しないで読み書きできます

## 2.3 io.Writerは「インタフェース」

以下の定義をみれば、これが「os パッケージのFile 型に定義されているWrite()というメソッド」ということがわかる

```
func (f *File) Write(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.write(b)
    :
}
```

`(f *File)` の部分は、この定義がFile 型の構造体へのポインタf に対するメソッドであることを示す

このWrite()は、fが指し示すファイルに対してバイト列bを書き込み、書き込んだバイト数nと、エラーが起きた場合はそのエラーerrorを返すものとして定義されている

(補足: Goでは、バイト列と文字列を表すstring 型とが、相互に変換可能)

バイト列bを書き込み、書き込んだバイト数nと、エラーが起きた場合はそのエラーerrorを返すというのは、通常のファイルに限らず、さまざまなものに適用できそう
→　「入出力に共通する仕様を満たすメソッドを持つ型」を統一的に扱えると便利そう

→　上記のような仕様のWrite() メソッドが宣言されているインタフェースこそが、io.Writer

```
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

`File` というデータ型の構造体には、その仕様どおりに定義されたWrite() メソッドがあります。

-> したがって、「*File はio.Writer インタフェースを満たす」といえます。

## 2.4 io.Writerを使う構造体の例

インタフェースは、構造体と違って何かしら実体を持つものを表すのではなく、「どんなことができるか」を宣言しているだけ

どのようなものがio.Writerインタフェースを満たすのかを見ていく

### 2.4.1 ファイル出力

`os.File`

`os.File`のインスタンスは、os.Create()（新規ファイルの場合）やos.Open()（既存のファイルのオープン）などの関数で作られる。

### 2.4.2 画面出力

`os.Stdout`

標準エラー出力に出力するためのos.Stderrもある。

### 2.4.3 書かれた内容を記憶しておくバッファ（1）: bytes.Buffer

他の例としては、Write() メソッドで書き込まれた内容を淡々とためておいてあとでまとめて結果を受け取れる`bytes.Buffer`。

bytes.Buffer には次章で紹介する、読み込みの抽象化のio.Reader の機能もあります。
この機能を使って読み出しをしたデータは消費されてしまうため、最後のbuffer.String()では取得できません

- バイト列に変換した文字列をWrite()メソッド
- 特別に文字列を受け取れるWriteString() というメソッド
  - WriteString() はio.Writer のメソッドではないため、他の構造体では使えません
  - 次のio.WriteString() 関数を使えばキャストは不要
    - `io.WriteString(buffer, "bytes.Buffer example\n")`


### 2.4.4 書かれた内容を記憶しておくバッファ（2）: strings.Builder

書き出し専用のbytes.Buffer 

読み出しがString() のみになっている以外はbytes.Buffer と置き換えて使える

### 2.4.5 インターネットアクセスの送信

net.Dial() 関数を使うと、net.Conn という通信のコネクションを表すインタフェースが返ってきます

- net.Conn は、io.Writer と次章で説明するio.Readerとのハイブリッドなインタフェース
- net.Conn インタフェースの実体は、net.TCPConn 構造体のポインタ

HTTP リクエストの作成に使う構造体がある
1. その構造体のメンバー変数を使ってヘッダーを追加するなどしてから、最後にWrite() メソッドを呼ぶことで、リクエストの内容をio.Writer に書き出せます
2. net.Conn を渡せばそのままサーバーにリクエストを送信できます

http.ResponseWriter

ウェブサーバーから、ブラウザに対してメッセージを書き込むのに使う

相手が何であろうと、io.Writerインタフェースを使うことで、どれも同じWrite()メソッドを使って書き出すことができます

### 2.4.6 io.Writerのデコレータ

### 2.4.7 フォーマットしてデータをio.Writerに書き出す

## 2.5 インタフェースの実装状況・利用状況を調べる

## 2.6 低レベルの機能を組み合わせて入出力APIを作る

## 2.7 柔軟性が高く、パフォーマンスのよい設計のためのTips

## 2.8 本章のまとめと次章予告

1. 共通する機能を抽象化するGo言語のインタフェースという仕組みにつ
   いて学び
2. 入出力に関するインタフェースのうちio.Writer について、このインタ
   フェースを満たす構造体をいくつか紹介

次章では、io.Writer と対照の存在であるio.Reader について紹介し

## 2.9 問題
