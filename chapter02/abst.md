# chapter 02 低レベルアクセスへの入口1： io.Writer

本章から3章分にわたって、Go言語がOS直上の低レイヤーを扱いやすくするために提供している抽象化レイヤーを紹介

この抽象化により低レイヤーを扱いやすい構造になっているから、簡単に、少ない記述で、比較的高速に、多くのことが達成できる

- io.Writer ：出力の抽象化
- io.Reader ：入力の抽象化
- channel ：通知の抽象化

## 2.1 io.WriterはOSが持つファイルのシステムコールの相似形

前章の例での最後にシステムコールsyscall.Write() が呼び出されているようすを見ました。
OSでは、このシステムコールを、ファイルディスクリプタといわれるものに対して呼びます。

ファイルディスクリプタ：
- 一種の識別子（数値）(e.g. `f.fd` )
- この数値を指定してシステムコールを呼び出すと、数値に対応するモノにアクセスできる
- ファイルに限らず、標準入出力、ソケット、OSやCPUに内蔵されている乱数生成の仕組みなど、本来ファイルではないものにも割り当てられる

ファイルディスクリプタは、OSがカーネルのレイヤーで用意している抽象化の仕組み

ただし同じPOSIX 系OSでも、Windowsだとソケットはファイルとして扱えなかったり、ファイル出力とコンソール出力でAPI が違っていたりして、
システムによる違いも少なからずある

Go言語では、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備し、OSによるAPI の差異を吸収しています。
その一例が、本章で取り上げるio.Writerです

`io.Writer`はGo言語のインタフェースという仕組みとして実装されているので、次節ではまずGo言語のインタフェースと、それに関連するGo言語の構造体について説明

Go言語でも、直接ファイルディスクリプタを指定してファイルのインスタンスを作り出す関数はあります。(cf: chap 6)
```
file, err := os.NewFile( ファイルディスクリプタ, 名前)
```

## 2.2 Go言語のインタフェース

Go言語のインタフェースは、構造体などの具象型が満たすべき仕様、つまりは持つべきメソッドを表現するための言語機能

Go言語にはクラスがなく、構造体しかありませんが、構造体がメソッドを持てます

func キーワードとメソッドのシグネチャの定義との間にレシーバーを置くと(ここでは`(g Greeter)`)、構造体にメソッドを定義したことになります
(副作用のあるメソッドではレシーバーの型をポインタ型（(g *Greeter)）にします。)

インタフェースで宣言されているすべてのメソッドが、データ型に対して定義されている場合、「そのデータ型はインタフェースを満たす」と表現

Go言語のコンパイラが、構造体のインスタンスのポインタをインタフェース型の変数に代入するコードを見つけると、そこで構造体とインタフェースの互換性をチェックします

Go言語では構造体がポインタであってもフィールド（構造体に含まれる各データ型）へのアクセスの方法は変わりませんし（いずれも「.」演算子が使えます）、
ガベージコレクタが適切に掃除してくれるため、宣言時以外はポインタであることを意識しないで読み書きできます

## 2.3 io.Writerは「インタフェース」

## 2.4 io.Writerを使う構造体の例

### 2.4.1 ファイル出力

### 2.4.2 画面出力

### 2.4.3 書かれた内容を記憶しておくバッファ（1）: bytes.Buffer

### 2.4.4 書かれた内容を記憶しておくバッファ（2）: strings.Builder

### 2.4.5 インターネットアクセスの送信

### 2.4.6 io.Writerのデコレータ

### 2.4.7 フォーマットしてデータをio.Writerに書き出す

## 2.5 インタフェースの実装状況・利用状況を調べる

## 2.6 低レベルの機能を組み合わせて入出力APIを作る

## 2.7 柔軟性が高く、パフォーマンスのよい設計のためのTips

## 2.8 本章のまとめと次章予告

1. 共通する機能を抽象化するGo言語のインタフェースという仕組みにつ
   いて学び
2. 入出力に関するインタフェースのうちio.Writer について、このインタ
   フェースを満たす構造体をいくつか紹介

次章では、io.Writer と対照の存在であるio.Reader について紹介し

## 2.9 問題
