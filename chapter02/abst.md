# chapter 02 低レベルアクセスへの入口1： io.Writer

本章から3章分にわたって、Go言語がOS直上の低レイヤーを扱いやすくするために提供している抽象化レイヤーを紹介

この抽象化により低レイヤーを扱いやすい構造になっているから、簡単に、少ない記述で、比較的高速に、多くのことが達成できる

- io.Writer ：出力の抽象化
- io.Reader ：入力の抽象化
- channel ：通知の抽象化

## 2.1 io.WriterはOSが持つファイルのシステムコールの相似形

前章の例での最後にシステムコールsyscall.Write() が呼び出されているようすを見ました。
OSでは、このシステムコールを、ファイルディスクリプタといわれるものに対して呼びます。

ファイルディスクリプタ：
- 一種の識別子（数値）(e.g. `f.fd` )
- この数値を指定してシステムコールを呼び出すと、数値に対応するモノにアクセスできる
- ファイルに限らず、標準入出力、ソケット、OSやCPUに内蔵されている乱数生成の仕組みなど、本来ファイルではないものにも割り当てられる

ファイルディスクリプタは、OSがカーネルのレイヤーで用意している抽象化の仕組み

ただし同じPOSIX 系OSでも、Windowsだとソケットはファイルとして扱えなかったり、ファイル出力とコンソール出力でAPI が違っていたりして、
システムによる違いも少なからずある

Go言語では、ファイルディスクリプタのような共通化の仕組みを言語レベルで模倣して整備し、OSによるAPI の差異を吸収しています。
その一例が、本章で取り上げるio.Writerです

`io.Writer`はGo言語のインタフェースという仕組みとして実装されているので、次節ではまずGo言語のインタフェースと、それに関連するGo言語の構造体について説明

Go言語でも、直接ファイルディスクリプタを指定してファイルのインスタンスを作り出す関数はあります。(cf: chap 6)
```
file, err := os.NewFile( ファイルディスクリプタ, 名前)
```

## 2.2 Go言語のインタフェース

Go言語のインタフェースは、構造体などの具象型が満たすべき仕様、つまりは持つべきメソッドを表現するための言語機能

Go言語にはクラスがなく、構造体しかありませんが、構造体がメソッドを持てます

func キーワードとメソッドのシグネチャの定義との間にレシーバーを置くと(ここでは`(g Greeter)`)、構造体にメソッドを定義したことになります
(副作用のあるメソッドではレシーバーの型をポインタ型（(g *Greeter)）にします。)

インタフェースで宣言されているすべてのメソッドが、データ型に対して定義されている場合、「そのデータ型はインタフェースを満たす」と表現

Go言語のコンパイラが、構造体のインスタンスのポインタをインタフェース型の変数に代入するコードを見つけると、そこで構造体とインタフェースの互換性をチェックします

Go言語では構造体がポインタであってもフィールド（構造体に含まれる各データ型）へのアクセスの方法は変わりませんし（いずれも「.」演算子が使えます）、
ガベージコレクタが適切に掃除してくれるため、宣言時以外はポインタであることを意識しないで読み書きできます

## 2.3 io.Writerは「インタフェース」

以下の定義をみれば、これが「os パッケージのFile 型に定義されているWrite()というメソッド」ということがわかる

```
func (f *File) Write(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.write(b)
    :
}
```

`(f *File)` の部分は、この定義がFile 型の構造体へのポインタf に対するメソッドであることを示す

このWrite()は、fが指し示すファイルに対してバイト列bを書き込み、書き込んだバイト数nと、エラーが起きた場合はそのエラーerrorを返すものとして定義されている

(補足: Goでは、バイト列と文字列を表すstring 型とが、相互に変換可能)

バイト列bを書き込み、書き込んだバイト数nと、エラーが起きた場合はそのエラーerrorを返すというのは、通常のファイルに限らず、さまざまなものに適用できそう
→　「入出力に共通する仕様を満たすメソッドを持つ型」を統一的に扱えると便利そう

→　上記のような仕様のWrite() メソッドが宣言されているインタフェースこそが、io.Writer

```
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

`File` というデータ型の構造体には、その仕様どおりに定義されたWrite() メソッドがあります。

-> したがって、「*File はio.Writer インタフェースを満たす」といえます。

## 2.4 io.Writerを使う構造体の例

インタフェースは、構造体と違って何かしら実体を持つものを表すのではなく、「どんなことができるか」を宣言しているだけ

どのようなものがio.Writerインタフェースを満たすのかを見ていく

### 2.4.1 ファイル出力

`os.File`

`os.File`のインスタンスは、os.Create()（新規ファイルの場合）やos.Open()（既存のファイルのオープン）などの関数で作られる。

### 2.4.2 画面出力

`os.Stdout`

標準エラー出力に出力するためのos.Stderrもある。

### 2.4.3 書かれた内容を記憶しておくバッファ（1）: bytes.Buffer

他の例としては、Write() メソッドで書き込まれた内容を淡々とためておいてあとでまとめて結果を受け取れる`bytes.Buffer`。

bytes.Buffer には次章で紹介する、読み込みの抽象化のio.Reader の機能もあります。
この機能を使って読み出しをしたデータは消費されてしまうため、最後のbuffer.String()では取得できません

- バイト列に変換した文字列をWrite()メソッド
- 特別に文字列を受け取れるWriteString() というメソッド
  - WriteString() はio.Writer のメソッドではないため、他の構造体では使えません
  - 次のio.WriteString() 関数を使えばキャストは不要
    - `io.WriteString(buffer, "bytes.Buffer example\n")`


### 2.4.4 書かれた内容を記憶しておくバッファ（2）: strings.Builder

書き出し専用のbytes.Buffer 

読み出しがString() のみになっている以外はbytes.Buffer と置き換えて使える

### 2.4.5 インターネットアクセスの送信

net.Dial() 関数を使うと、net.Conn という通信のコネクションを表すインタフェースが返ってきます

- net.Conn は、io.Writer と次章で説明するio.Readerとのハイブリッドなインタフェース
- net.Conn インタフェースの実体は、net.TCPConn 構造体のポインタ

HTTP リクエストの作成に使う構造体がある
1. その構造体のメンバー変数を使ってヘッダーを追加するなどしてから、最後にWrite() メソッドを呼ぶことで、リクエストの内容をio.Writer に書き出せます
2. net.Conn を渡せばそのままサーバーにリクエストを送信できます

http.ResponseWriter

ウェブサーバーから、ブラウザに対してメッセージを書き込むのに使う

相手が何であろうと、io.Writerインタフェースを使うことで、どれも同じWrite()メソッドを使って書き出すことができます

### 2.4.6 io.Writerのデコレータ

デコレータとは、オブジェクトをラップして追加の機能を実現するという、GoFのデザインパターン用語のデコレータのこと。

io.MultiWriter() は、複数のio.Writerを受け取り、それらすべてに対して、書き込まれた内容を同時に書き込むデコレータ

書き込まれたデータをgzip 圧縮して、あらかじめ渡されていたos.File に中継するというサンプルコード(ファイルの内容を加工するフィルター)

出力結果を一時的にためておいて、ある程度の分量ごとにまとめて書き出す`bufio.Writer`という構造体:
― 2.4.3「書かれた内容を記憶しておくバッファ（1）: bytes.Buffer」で紹介したbytes.Bufferではない
- Flush()メソッドを呼ぶと、後続のio.Writerに書き出します。
- Flush() メソッドを呼ばないと、書き込まれたデータを腹に抱えたまま消滅してしまう

Flush() を自動で呼び出す場合には、バッファサイズ指定の`bufio.NewWriterSize(os.Stdout, バッファサイズ)` 関数でbufio.Writer を作成
(デフォルトでは4096バイトに設定されています。)
- もし、大量のサイズの入出力、あるいは高頻度の入出力を行うのであれば、アプリケーションの特性に合わせてバッファサイズを決める必要があります
  - I/O 速度や速度の安定性によっては一度のサイズを増やしたり
  - 応答性重視であればサイズを絞るといった調整をしたり

### 2.4.7 フォーマットしてデータをio.Writerに書き出す

`fmt.Fprintf()`: 
- 整形したデータをio.Writer へと書き出す汎用の関数
- フォーマット（2 つめの引数）に従って、io.Writer（最初の引数）にデータ（3つめ以降の引数）を書き出す
- Go言語にはなんでも表示できる`%v` というフォーマット指定子があり、プリミティブ型でもそうでない型でも
`String()`メソッドがあればそれを表示に使って出力してくれます
  - (これもfmt.Stringer インタフェースとして定義されています)

io.Writer に書き出すメソッドを持つ、用途が限定された構造体もある。
- net/httpパッケージのRequest構造体
  - クライアント側のリクエストを送るときにも
    - io.Writerに書き出す用途はリクエストを送るとき
  - サーバー側でレスポンスを返すときにクライアントの情報をパースするのにも
- この構
  造体のWrite() メソッドを使わないといけないケースは実際には少ないですが、
  Transfer-Encoding: chunked でチャンクに分けて送信したり、プロトコルの
  アップグレードで別のプロトコルと併用するようなHTTPリクエストを送るときには
  使うことになるでしょう

## 2.5 インタフェースの実装状況・利用状況を調べる

「このインタフェースを満たしています」という宣言を構造体側にはいっさい書きません

構造体がインタフェースを満たすメソッドを持っているかどうかは、
インタフェースの変数に構造体のポインタを代入したり、メソッドの引数にポインタを渡したりするときに、自動的に確認

どの構造体がこのインタフェースを満たしているかに便利なツール、godoc

ウェブサーバーとして起動してブラウザで見るのが典型的な使い方ですが、
起動時に次のように`-analysis type`を付けることでインタフェースの分析を行ってくれます。

(公式ドキュメントでは`godoc -analysis=type`となっている。)

-analysis type を付けて実行すると、golang.org にはない「implements」という項目が追加されます

(表示されなかった...)

io.Writer 関連の構造体がたくさんあるといっても、すべてを覚えておく必要はなく、そのつどリファレンスを引けばいいだけ

## 2.6 低レベルの機能を組み合わせて入出力APIを作る

確かにGo言語には、ファイル読み込みやネットワークアクセスの結果が1行で得られる、関数が用意されています。

- `ioutil.WriteFile()`： これだけを使ってファイルに書き込める
- `ioutil.ReadFile()`： これだけを使ってファイルから読み込める
- `http.Get()`： これだけを使ってHTTPのGETメソッドでデータを受け取れる
- `http.Post()`： これだけを使ってHTTPのPOSTメソッドでデータを送れる

実はこれらのAPI は、本章の主役であるio.Writer や次章で取り上げるio.Reader を隠蔽して、特定の用途で簡単に使えるようにしたもの

部品を知ることで、高レベルな関数の実装を知ったり、自分で作れるようになります。それが低レベルを知ることの強みのひとつといえるでしょう

## 2.7 柔軟性が高く、パフォーマンスのよい設計のためのTips

## 2.8 本章のまとめと次章予告

1. 共通する機能を抽象化するGo言語のインタフェースという仕組みにつ
   いて学び
2. 入出力に関するインタフェースのうちio.Writer について、このインタ
   フェースを満たす構造体をいくつか紹介

次章では、io.Writer と対照の存在であるio.Reader について紹介し

## 2.9 問題
