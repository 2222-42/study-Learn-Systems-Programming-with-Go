# 第4章  低レベルアクセスへの入口3： チャネル

チャネルは低レベルアクセスの抽象化だけではなく、
並列処理のプログラミングにおいて並列で行われる処理の同期を取るのにも使われる高水準の機能

1. Go言語のチャネル機能について説
2. OS とのインタフェースとしてチャネルを使用する例

(他の章で扱うこと：
- アプリケーションレイヤーにおけるチャネルを使った並列処理の応用例 cf: chapter 13
- チャネルを使って応答を受けるインタフェースの例としてタイマー cf: chapter 16
)

## 4.1 goroutine

Sのネイティブなスレッドを扱いやすくしたgoroutineという並列処理機構

「go というキーワードを付けて実行すればgoroutineが作られて並列実行される」という理解で十分

`go Function()`で既存の関数`Func()`を呼び出し並列処理を実行できる。

無名関数（クロージャ）を使って、関数の作成とgoroutine 化を同時に行うこともできる

## 4.2 チャネル

キュー（queue）と呼ばれるデータ構造

Go言語のチャネルは、このキューに並列処理用の「並列でアクセスされても正しく処理される」ことを保証する機能を組み合わせたもの

- CSP（Communicating Sequential Processes）というモデル由来
- お互いのプロセス(スレッドなどの処理の単位;OSプロセスとは異なる)が同じデータを直接触るのではなく、コミュニケーションを行いつつ協調する構造にすることで、
- 難しい並行処理のプログラミングを簡単にしつつ、壊れにくいコードを書くことができます

チャンネルの3つの機能:

- データを順序よく受け渡すためのデータ構造である
  - キューとしてのチャネルは、データをためる配列
  - ランダムアクセスできない
    - 投入と取り出しだけができる
    - 投入した順番に値が出てくる
- 並列処理されても正しくデータを受け渡す同期機構
  - 整合性が壊れることがない、安全なデータ構造
    - 複数のgoroutine でチャネルに読み書きを行っても、1 つのgoroutine だけがデータを投入できます。
    - データの取り出しも、同時に1 つのgoroutine だけ
  - goroutine 間の情報共有方法としてチャネルを使うことが推奨
- 読み込み・書き込みで準備ができるまでブロックする機能
  - データがない状態で読み込みをしようとすると、他のgoroutine がそのチャネルにデータを投入して読み込みの準備ができるまでブロックして待つ
  - バッファに空きがない状態で書き込みをしようとすると、他のgoroutine がデータを取り出して空きができるまでブロック
  - 待ち合わせや通知にチャネルが使われる
    - システムプログラミング的な低レベルアクセスで、OS側から通知を受け取るインタフェース(情報の入出力の境界)として、
    「データ投入まで待つ」という機能を持つチャネルが使われます

使用例：

- データ入力元、データ出力先、終了状態の伝達

終了とタイムアウトの管理にコンテキスト（context.Context）という仕組みを利用するが、このコンテキストの終了判定（Done() メソッド）もチャネルを介して行う

### 4.2.1 チャネルの使用方法

チャネルを作るには、`make()`

チャネルへデータを送信したり、チャネルからデータを受信するには、`<-演算子`

受取時に変数を2つ書くと、2つ目の変数にはbool型であれば、そこで、クローズ判定も取れる(Openだったらtrue)

ブロックを避けるには、4.2.4 項で説明する`select`を使う方法があります

チャネルを閉じるには組み込み関数の`close( チャネル)` を呼ぶ
- そのチャネルを使っているループが終了します
- 読み込みではデフォルト値（数値なら0、文字列なら空文字列など）が返ってくるようになり、
- 送信しようとするとパニック

意味のあるデータを送信する以外にも、何かしらのイベントの通知で使われることがあります。
特に並列処理で処理が終了したことの通知でよく使われます

注意が必要なのは、クローズされているかどうかを受信側に確実に知らせるための明確な方法がない点
-> プログラムの意図を明確にするには、終了情報のやり取りのために別のチャネルを利用すべきです

チャネルは、クローズしなくてもガベージコレクタに回収されます。
- データを流すチャネルは、正常なデータに本来入れてないデータ（ゼロ、空文字列など）が紛れ込んでしまう可能性があるため、クローズしないほうがよい
- 終了情報のシグナルを目的としたチャネルは、複数のgoroutine が監視している場合でもすべてに終了を通知できるため、close()を行うほうがよい

### 4.2.2 チャネルの3つの状態

### 4.2.3 for文

### 4.2.4 チャネルとselect文

### 4.2.5 コンテキスト

## 4.3 システムからの通知

### 4.3.1 OSからのシグナルをチャネルで受け取る例

## 4.4 本章のまとめと次章予告

### 4章のまとめ

Go言語において珍しくリッチな機能を与えられているチャネルについて

次のような3 つのチャネルの役割を説明し、3 つめの機能が通知のインタフェースとして使われている点について説明

1. データを順序よく受け渡すためのデータ構造
2. 並列処理されても正しくデータを受け渡す同期機構
3. 読み込み・書き込みで準備ができるまでブロックする機能

Go言語のチャネルは、自由に使いこなせるまでには時間がかかるかも
-> 最初は、な既存のライブラリを使ってみることを筆者は勧める

### 今後の方針

io.Writer、io.Reader という余計な情報を理解しないと入出力を使いこなせないGo言語にとっつきにくさを感じるかもしれない

裏を返せば、この部分がわかれば低レベルな層との付き合いが格段に楽になる

以降の章では、ここまでに紹介した機能をいろいろ使って、ソケットなどの低レベルな入出力も扱っていく。

### 次章の予告

OS とアプリケーションの境界線であるシステムコールを再訪

## 4.5 問題
